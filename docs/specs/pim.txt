
EDU device
==========

Copyright (c) 2020 Emanuele Giuseppe Esposito
This document is licensed under the GPLv2 (or later).

This is an educational device for writing (kernel) drivers. Its original
intention was to support the Linux kernel lectures taught at the Masaryk
University. Students are given this virtual device and are expected to write a
driver with I/Os, IRQs, DMAs and such.

The devices behaves very similar to the PCI bridge present in the COMBO6 cards
developed under the Liberouter wings. Both PCI device ID and PCI space is
inherited from that device.

Command line switches:
    -device edu[,dma_mask=mask]

    dma_mask makes the virtual device work with DMA addresses with the given
    mask. For educational purposes, the device supports only 28 bits (256 MiB)
    by default. Students shall set dma_mask for the device in the OS driver
    properly.

PCI specs
---------

PCI ID: 1234:11e8

PCI Region 0:
   I/O memory, 1 MB in size. Users are supposed to communicate with the card
   through this memory.

MMIO area spec
--------------

Only size == 4 accesses are allowed for addresses < 0x80. size == 4 or
size == 8 for the rest.

0x00 (RO) : identification (0xRRrr00edu)
	    RR -- major version
	    rr -- minor version

0x04 (RW) : card liveness check
	    It is a simple value inversion (~ C operator).

0x08 (RW) : summation computation
	    The stored value is taken and summation (sum += val--) of it is put back here.
	    This happens only after summation bit in the status register
	    is cleared.

0x10 (RW) : status register, bitwise OR
	    0x01 -- computing summation (RO)
	    0x80 -- raise interrupt after finishing summation computation

----------------------------------------------------------------

0x18 (RO) : interrupt status register
	    It contains values which raised the interrupt (see interrupt raise
	    register below).

0x20 (WO) : interrupt raise register
	    Raise an interrupt. The value will be put to the interrupt status
	    register (using bitwise OR).

0x24 (WO) : interrupt acknowledge register
	    Clear an interrupt. The value will be cleared from the interrupt
	    status register. This needs to be done from the ISR to stop
	    generating interrupts.

----------------------------------------------------------------

0x30 (WO) : DMA source address
	    Where to perform the DMA from (physical address).

0x38 (WO) : DMA destination address
	    Where to perform the DMA to (physical address).

0x40 (WO) : DMA transfer count
	    The size of the area to perform the DMA on.

0x48 (WO) : DMA command register, bitwise OR
	    0x01 -- direction (0: from RAM to PIM, 1: from PIM to RAM)
	    0x02 -- copy dest with value of source (size of count)

0x50 - 0x6b : 28 bytes for more commands

0x6b (WO):  Memsets DMA buffer at 0x40000 with given value

----------------------------------------------------------------

0x70 (WO) : Local DMA src memory address

0x78 (WO) : Local DMA dest memory address

0x80 (WO) : Local DMA transfer count
	    The size of the area to perform the DMA on.

0x88 (WO) : DMA command register, bitwise OR
	    0x01 -- direction (0: from local RAM to PIM, 1: from PIM to local RAM)
	    0x02 -- copy dest with value of source (size of count)

0x90 - 0x10b : 28 bytes for more commands

0x10b (WO):  Memsets local buffer at 0x50000

----------------------------------------------------------------

0x110 (RW):  Read/Writes buffer at 0x40000

0x1110 (RW):  Read/Writes local buffer at 0x50000

IRQ controller
--------------
An IRQ is generated when written to the interrupt raise register. The value
appears in interrupt status register when the interrupt is raised and has to
be written to the interrupt acknowledge register to lower it.

The device supports both INTx and MSI interrupt. By default, INTx is
used. Even if the driver disabled INTx and only uses MSI, it still
needs to update the acknowledge register at the end of the IRQ handler
routine.

DMA controller
--------------
One has to specify, source, destination, size, and start the transfer. One
4096 bytes long buffer at offset 0x40000 is available in the EDU device. I.e.
one can perform DMA to/from this space when programmed properly.

Example of transferring a 100 byte block to and from the buffer using a given
PCI address 'addr':
addr     -> DMA source address
0x40000  -> DMA destination address
100      -> DMA transfer count
1        -> DMA command register
while (DMA command register & 1)
	;

0x40000  -> DMA source address
addr+100 -> DMA destination address
100      -> DMA transfer count
3        -> DMA command register
while (DMA command register & 1)
	;
